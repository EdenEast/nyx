#!/usr/bin/env bash

set -e

# shellcheck shell=bash
INTERNAL_COMMANDS="^(add|clone|help|list|remove|root|source|switch)$"

declare -A INTERNAL_ALIASES
INTERNAL_ALIASES['a']="add"
INTERNAL_ALIASES['c']="clone"
INTERNAL_ALIASES['r']="root"
INTERNAL_ALIASES['s']="switch"

function main() {
  WT_COMMAND="help"
  WT_ARGS=()

  # Parse command line options
  if [ -n "$*" ]; then
    if [[ $1 == '--help' ]]; then
      HELP=true
    elif [[ $1 =~ $INTERNAL_COMMANDS ]]; then
      WT_COMMAND="${1//-/_}"
      shift
    else
      internal_command="${INTERNAL_ALIASES[$1]}"
      if [ -n "$internal_command" ]; then
        WT_COMMAND="$internal_command"
        shift
      fi
    fi
  fi

  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
      -h | --help)
        CMD_HELP=true
        ;;
      *)
        WT_ARGS+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$HELP" ] && cmd_help

  "cmd_$WT_COMMAND" "${WT_ARGS[@]}"

  exit 0
}

# --- Commands ----------------------------------------------------------------

function cmd_add() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
Add a new worktree

USAGE:
  wt add [OPTIONS] [name] [path]

OPTIONS:
  -h, --help    Prints help information

ARGS:
  <name>        The name of the branch
  <path>        The name of the new directory to clone into
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  local root
  root=$(get_root_dir)

  local name
  local path
  name="${args[0]}"
  path="${args[1]}"

  if [ -z "$name" ]; then
    name=$(git ls-remote --heads ./. | awk '{print $2}' | cut -c 12- | fzf-down)
  fi

  if [ -z "$path" ]; then
    path="$name"
  fi

  local full="$root/$path"

  if [ ! -e "$full" ]; then
    git worktree add "$full" "$name"
  fi
}

function cmd_clone() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
Clone a repository into a new directory.

USAGE:
  wt clone [OPTIONS] <repository> [path]

ALIAS: 'c'

OPTIONS:
  -b, --branch <name>   Initial branch to clone to
  -u, --upstream <url>  Upstream remote to track
  -h, --help            Prints help information

ARGS:
  <repository>          The (remote) repository to clone from
  <path>                The name of the new directory to clone into
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -b | --branch)
        starting_branch="$2"
        shift
        ;;
      -u | --upstream)
        upstream="$2"
        shift
        ;;
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  local url="${args[0]}"
  local basename=${url##*/}
  local name=${args[1]:-${basename%.git}}

  mkdir "$name"
  cd "$name"

  # Move the top level .git folder (A.K.A the $GIT_DIR) to .bare directory
  #
  # The target folder structure looks like the following:
  # .bare/
  # main/
  # feature/
  git clone --bare "$url" .bare
  echo "gitdir: ./.bare" >.git

  # Explicitly sets the remote origin fetch so we can fetch remote branches
  # This is required because cloning with `--bare` repository does not set
  # The remote for origin
  git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
  echo "# vim:ft=gitconfig" >>./.bare/config
  git fetch origin

  if [ -n "$upstream" ]; then
    git remote add upstream "$upstream"
    git fetch upstream
  fi

  # Getting the default branch of the remote and settings the remote's HEAD
  local default_branch symref
  symref="$(git symbolic-ref HEAD)"
  default_branch="${symref##refs/heads/}"
  git remote set-head origin "$default_branch"

  if [ -z "$starting_branch" ]; then
    starting_branch="$default_branch"
  fi

  # Creating the first worktree with the default branch
  git worktree add "$starting_branch"
}

function cmd_help() {
  if [[ $1 =~ $INTERNAL_COMMANDS ]]; then
    $1 '--help'
  fi

  set +e
  local msg
  IFS='' read -r -d '' msg <<EOF
Utility script to work with git worktree's

USAGE:
  wt [OPTIONS] <command>

COMMANDS:
  add            Add a new worktree
  clone          Clone a repository into a new directory
  help           Utility script to work with git worktree's
  list           List worktrees
  remove         Remove worktree
  root           Return the root of the repository
  source         Output wt wrapper function to be source in rc file
  switch         Switch directory to a different worktree

OPTIONS:
  -h, --help     Prints help information
EOF
  set -e

  printf "%s\n" "$msg"
  exit 1
}

function cmd_list() {
  set +e
  local msg
  IFS='' read -r -d '' msg <<EOF
List worktrees

USAGE:
  wt list [OPTIONS]

OPTIONS:
  -h, --help     Prints help information
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  git worktree list
}

function cmd_remove() {
  set +e
  local msg
  IFS='' read -r -d '' msg <<EOF
Remove worktree

USAGE:
  wt remove [OPTIONS] [path]

OPTIONS:
  -f, --force    Force removal of worktree
  -h, --help     Prints help information

ARGS:
  <path>         Fuzzy name of switch target
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f | --force)
        force="--force"
        shift
        ;;
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  local path
  path="${args[0]}"

  if [ -z "$name" ]; then
    path=$(git worktree list | tail -2 | fzf-down | awk '{print $1}')
  fi

  git worktree remove "$path" $force
}

function cmd_root() {
  set +e
  local msg
  IFS='' read -r -d '' msg <<EOF
Return the root of the repository

USAGE:
  wt root [OPTIONS]

ALIAS: 'r'

OPTIONS:
  -h, --help    Prints help information
EOF
  set -e

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  get_root_dir
}

function cmd_source() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
Output wt wrapper function to be source in rc file

USAGE:
  wt source [OPTIONS]

OPTIONS:
  -h, --help    Prints help information
EOF
  set -e

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  cat <<EOF
function wt() {
  if [[ "\$1" =~ ^\(switch\|s\)\$ ]]; then
    SCRIPT="\$(command wt \$@)"
    [ \$? -eq 0 ] && eval "\$SCRIPT" || printf "\$SCRIPT"
  else
    command wt \$@
  fi
}

# =============================================================================
#
# To initialize wt, add this to your configuration (usually ~/.bashrc):
#
# [ -x "\$(command -v wt)" ] && eval "\$(wt source)"
EOF
}

function cmd_switch() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
Switch directory to a different worktree

USAGE:
  wt switch [OPTIONS] [name]

ALIAS: 's'

OPTIONS:
  -h, --help    Prints help information

ARGS:
  <name>        Fuzzy name of switch target
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  local selected
  selected="$(git worktree list | fzf-down)"

  if [[ $selected =~ \(bare\)$ ]]; then
    selected="$(echo "$selected" | awk '{print $1}')"
    selected="$(dirname "$selected")"
  else
    selected="$(echo "$selected" | awk '{print $1}')"
  fi

  echo "cd \"$selected\""
}

# --- Utility -----------------------------------------------------------------

function get_root_dir() {
  dirname $(realpath $(git rev-parse --git-common-dir))
}

function fzf-down() {
  fzf --height 40% --reverse
}

# --- Execute main process ----------------------------------------------------

main "$@"

# vim: et sw=2 ts=2 sts=2
