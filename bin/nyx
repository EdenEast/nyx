#!/usr/bin/env bash

set -e

# color chart https://stackoverflow.com/a/5947802
RED='\033[0;31m'
GRN='\033[0;32m'
YLO='\033[0;33m'
BLU='\033[0;34m'
MTA='\033[0;35m'
CYN='\033[0;36m'
RST='\033[0m'

NYX_ROOT="$(dirname $(dirname "$(readlink -f "$0")"))"
HOME_MANAGER_BACKUP_EXT="nbak"

# shellcheck shell=bash
INTERNAL_COMMANDS="^(build|check|fmt|gc|help|link|switch|update|unlink)$"

NIXARGS=(--experimental-features "nix-command flakes")
NIXBUILDARGS=(
  --option 'extra-substituters' 'https://cachix.cachix.org https://nix-community.cachix.org https://edeneast.cachix.org'
  --option 'extra-trusted-public-keys' 'cachix.cachix.org-1:eWNHQldwUO7G2VkjpnjDbWwy4KQ/HNxht7H4SSoMckM= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs= edeneast.cachix.org-1:a4tKrKZgZXXXYhDytg/Z3YcjJ04oz5ormt0Ow6OpExc='
)

declare -A TARGETS
declare -A SOURCES
TARGETS['nvim']="$HOME/.config/nvim"
SOURCES['nvim']="$NYX_ROOT/config/.config/nvim"
TARGETS['awesome']="$HOME/.config/awesome"
SOURCES['awesome']="$NYX_ROOT/config/.config/awesome"
TARGETS['wezterm']="$HOME/.config/wezterm"
SOURCES['wezterm']="$NYX_ROOT/config/.config/wezterm"

function main() {
  # Parse command line options
  if [ -z "$*" ]; then
    help # There is no arguments passed print help
  elif [[ $1 == '--help' ]]; then
    HELP=true
  elif [[ $1 =~ $INTERNAL_COMMANDS ]]; then
    NYX_COMMAND="${1//-/_}"
    NYX_ARGS=()
    shift

    while [[ $# -gt 0 ]]; do
      key="$1"
      case $key in
        -v | --verbose) # used by all commands
          DEBUG="YES"
          ;;
        -h | --help)
          CMD_HELP=true
          ;;
        *)
          NYX_ARGS+=("$1")
          ;;
      esac
      shift
    done
  else
    failure "Unknown command: \`$1\`"
    help
  fi

  [ -n "$HELP" ] && help

  $NYX_COMMAND "${NYX_ARGS[@]}"
  exit 0
}

# --- Commands ----------------------------------------------------------------

function build() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
USAGE: nyx build [target]

Build an output target. If no output target is specified nyx will build
either the nixos system configuration or the toplevel host config.

OPTIONS:
  -h, --help      Show help message
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  (
    cd "$NYX_ROOT"

    # If a build target has been specified then tell nix build this target
    if [[ ${#args[@]} -gt 0 ]]; then
      debug "target argument was passed to build. Building ${args[0]}"
      nix build ".#top.${args[0]}" "${NIXARGS[@]}" "${NIXBUILDARGS[@]}"
    else
      # There was no target passed to build so infer what do build
      if is_nixos >/dev/null; then
        debug "Nixos detected building NixosConfiguration for the host machine: $(hostname)"
        sudo nixos-rebuild build --flake .
      else
        debug "Nixos not detected, building target based on \$USER: $USER"
        # When not on nixos it is harder to infer what we are supposed to build for the platform if we cant
        # infer then nix build will just run and build the default package.
        # TODO: This is wrong and should save what top target should be built for the machine.
        nix build ".#top.$USER" "${NIXARGS[@]}" "${NIXBUILDARGS[@]}"

        # # Could not infer and building the default package
        # debug "Could not infer target to build, building default package for the flake"
        # nix build "${NIXARGS[@]}" "${NIXBUILDARGS[@]}"
      fi
    fi
  )
}

function check() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
USAGE: nyx check

Execute flake check output.

OPTIONS:
  -h, --help      Show help message
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  (
    cd "$NYX_ROOT"

    nix flake check
  )
}

function fmt() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
USAGE: nyx fmt [OPTIONS] [target...]

Execute formatters for file types.

OPTIONS:
  -h, --help      Show help message
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  (
    cd "$NYX_ROOT"

    # Formatting *.nix files
    nix-shell -p fd -p nixpkgs-fmt --run "fd . --type f --extension nix --exec nixpkgs-fmt {}"

    (
      cd "config/.config/nvim"
      nix-shell -p stylua --run "stylua -g *.lua -- ."
    )
  )
}

function gc() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
USAGE: nyx gc [OPTIONS] [target...]

Garbage collection and nix store optimization

OPTIONS:
  -h, --help      Show help message
  -a, --all       GC both user and system profiles
  -s, --system    Only gc system profile
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -a | --all) do_all=true ;;
      -s | --system) do_system=true ;;
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  if [ -n "$do_all" ] || [ -n "$do_system" ]; then
    info "Cleaning up system profile"
    sudo nix-collect-garbage -d
    sudo nix-store --optimize

    # nix-collect-garbage is a Nix tool, not a NixOS tool. It won't delete old
    # boot entries until you do a nixos-rebuild (which means we'll always have
    # 2 boot entries at any time). Instead, we properly delete them by
    # reloading the current environment.
    sudo nix-env --delete-generations old --profile /nix/var/nix/profiles/system
    sudo /nix/var/nix/profiles/system/bin/switch-to-configuration switch
  fi

  if [ -n "$do_all" ] || [ -z "$do_system" ]; then
    info "Cleaning up system profile"
    nix-collect-garbage -d
  fi
}

function link() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
USAGE: nyx link [OPTIONS] [target...]

Create a symlink to config file. If no application is given all will be provided.

TARGETS:
  nvim
  awesome

OPTIONS:
  -h, --help      Show help message
  -l, --list      Show status of current links
                    - Green:  Linked to local 'config/'
                    - Cyan:   Linked to the nix store
                    - Yellow: Linked to somewhere other then /nix/store
                    - Red:    Target points to a non linked directory
                    - Blue:   Target does not exist on system
EOF

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -l | --list)
        do_list=true
        ;;
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  [ -n "$do_list" ] && {
    for key in "${!SOURCES[@]}"; do
      src="${SOURCES[$key]}"
      tar="${TARGETS[$key]}"

      if [ -L "$tar" ]; then
        output=$(readlink "$tar")
        if [[ $output == "$src" ]]; then
          color="$GRN"
        else
          [[ $output =~ ^/nix/store/.* ]] && color="$CYN" || color="$YLO"
        fi
      else
        if [ -d "$tar" ] || [ -f "$tar" ]; then
          output="$tar"
          color="$RED"
        else
          color="$BLU"
          output="---"
        fi
      fi
      printf "${color}%*s${RST}: %s\n" 10 "$key" " $output"
    done

    exit 0
  }

  function create_link() {
    if [[ -L $1 ]]; then
      if [[ "$(readlink $1)" == "$2" ]]; then
        debug "link: $1 already points to $2. Skipping"
        return
      else
        debug "Found link: \`$1\` removing"
        rm "$1"
      fi
    fi

    if [[ -d $1 ]]; then
      warn "path: \`$1\` is a directory. Skipping"
      return
    fi

    ln -s "$2" "$1"
    if [[ "$(readlink "$1")" == "$2" ]]; then
      debug "created link $1 to $2"
    else
      failure "created link $1 does not point to $2. Points to $(readlink $1)"
    fi
  }

  (
    cd "$NYX_ROOT"

    if [[ ${#args[@]} -gt 0 ]]; then
      for index in "${!args[@]}"; do
        key="${args[$index]}"
        target="${TARGETS[$key]}"
        source="${SOURCES[$key]}"
        if [[ -z $target ]] || [[ -z $source ]]; then
          failure "unknown target $key"
        fi

        create_link "$target" "$source"
      done
    else
      for key in "${!TARGETS[@]}"; do
        create_link "${TARGETS[$key]}" "${SOURCES[$key]}"
      done
    fi
  )

  set -e
}

function switch() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
USAGE: nyx switch [OPTIONS] [target...]

Switch the current installed configuration state.

OPTIONS:
  -h, --help      Show help message
  -l, --link      Link after switch
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -l | --link)
        do_link=true
        ;;
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  (
    cd "$NYX_ROOT"

    # Making sure that the target builds before trying to unlink and switch
    build "${NYX_ARGS[@]}"

    # Since the build completed with no issues then it is safe to unlink
    # and switch to the new config
    unlink

    # Switch to new configuration
    if [[ ${#args[@]} -gt 0 ]]; then
      if is_nixos > /dev/null; then
        debug "Switching to defined target ${args[0]} on nixos system"
        sudo nixos-rebuild switch --flake ".#top.${args[0]}"
      else
        debug "Switching to defined target ${args[0]} on non nixos system"
        ./result/activate
      fi
    else
      if is_nixos > /dev/null; then
        debug "Nixos detected switching NixosConfiguration for the host machine: $(hostname)"
        sudo nixos-rebuild switch --flake . # TODO: How do force to use extra binary caches?
      else
        debug "Nixos not detected, switching target based on \$USER: $USER"
        # When not on nixos is is harder to infer what we are supposed to build for the platform if we cant
        # infer then nix build will just run and build the default package.
        # TODO: This is wrong and should save what top target should be built for the machine.
        ./result/activate

        # # Could not infer and building the default package
        # debug "Could not infer target to build, building default package for the flake"
        # nix build "${NIXARGS[@]}" "${NIXBUILDARGS[@]}"
      fi
    fi

    [ -n "$do_link" ] && link
  )
}

function update() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
USAGE: nyx update [OPTIONS] [inputs...]

Update flake.lock file

OPTIONS:
  -h, --help      Show help message
EOF
  set -e

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  (
    cd "$NYX_ROOT"

    # TODO: update flake-url / inputs
    nix flake update
  )
}

function unlink() {
  set +e
  local help_msg
  IFS='' read -r -d '' help_msg <<EOF
USAGE: nyx unlink [OPTIONS] [targets...]

Remove manual symlinks to config/ folder

TARGETS:
  nvim
  awesome

OPTIONS:
  -h, --help      Show help message
EOF

  local -a args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      *)
        args+=("$1")
        ;;
    esac
    shift
  done

  [ -n "$CMD_HELP" ] && {
    printf "%s\n" "$help_msg"
    exit 1
  }

  function remove_link() {
    if [[ -L $1 ]]; then
      if [[ $(readlink "$1") == "$2" ]]; then
        debug "link: $1 points to nyx config folder $2. Removing"
        rm "$1"
      else
        debug "link $1 does not point to nyx config folder: $(readlink $1)"
      fi
    fi
  }

  (
    cd "$NYX_ROOT"

    if [[ ${#args[@]} -gt 0 ]]; then
      for index in "${!args[@]}"; do
        key="${args[$index]}"
        target="${TARGETS[$key]}"
        source="${SOURCES[$key]}"
        if [[ -z $target ]] || [[ -z $source ]]; then
          failure "unknown target $key"
        fi

        remove_link "$target" "$source"
      done
    else
      for key in "${!TARGETS[@]}"; do
        remove_link "${TARGETS[$key]}" "${SOURCES[$key]}"
      done
    fi
  )

  set -e
}

function help() {
  if [[ $1 =~ $INTERNAL_COMMANDS ]]; then
    $1 '--help'
  fi

  set +e
  local msg
  IFS='' read -r -d '' msg <<EOF
Utility script to work with my nix configuration more effectively

USAGE: nyx <COMMAND> [OPTIONS...]

COMMANDS:
  build  - Build target
  check  - Execute flake check
  fmt    - Execute formatters
  gc     - Garbage collection and nix store optimization
  link   - Symlink config locations in config/ to ~/.config
  switch - Switch to configuration
  update - Update flake inputs
  unlink - Remove custom link from the \`link\` command

OPTIONS:
  -v, --verbose  - Output verbose information
  -h, --help     - Output help information
EOF
  set -e

  printf "%s\n" "$msg"
  exit 1
}

# --- Utility functions -------------------------------------------------------

function get_distro() {
  cat /etc/*-release | grep '^ID=' | cut -c4-
}

function is_nixos() {
  [ "$(get_distro)" == "nixos" ] && echo 1
}

function debug() {
  if [ -n "$DEBUG" ]; then echo_e "${BLU}[DEBUG]: $*${RST}"; fi
}

function info() {
  echo_e "$*"
}

function warn() {
  echo_e "${YLO}[WARN]: $*${RST}"
}

function error() {
  echo_e "${RED}[ERROR]: $*${RST}" 1>&2
}

function failure() {
  error $1
  exit ${2:-1}
}

# --- Echo replacements -------------------------------------------------------

function echo() {
  IFS=' '
  printf '%s\n' "$*"
}

function echo_n() {
  IFS=' '
  printf '%s' "$*"
}

function echo_e() {
  IFS=' '
  printf '%b\n' "$*"
}

# --- Execute main process ----------------------------------------------------
main $*

# vim: et sw=2 ts=2 sts=2
